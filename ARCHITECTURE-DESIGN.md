# Architecture Design for Multi-Tenant Global Competition Platform
## Architecture Overview
The platform could use a shared database (pool model) with strong logical isolation per school. Each table (e.g. users, competitions, etc.) includes a tenant_id (school ID) and PostgreSQL Row-Level Security (RLS) policies to ensure every query is filtered by tenant. This “single database, shared schema” approach is cost-effective and scalable. Tenant isolation is enforced centrally by the database, avoiding ad-hoc checks in application code. For example, a simple policy can append WHERE tenant_id = auth.uid() so each school can only see its own rows.
## Multi-Tenant Data Model & Visibility
All core entities (e.g. schools, users, competitions) include tenant_id. The Competitions table has fields like id, title, tenant_id, and a visibility flag (ENUM: public, private, restricted). A separate join table (e.g. competition_allowed_schools) lists which schools can view a “restricted” competition. RLS policies enforce visibility rules. For instance: if visibility = public, any user can see it; if private, only tenant_id matches; if restricted, the current school’s ID must appear in the join table. Because PostgreSQL RLS adds an implicit WHERE clause on queries, it guarantees no cross-tenant data leakage. Indexes on tenant_id and visibility fields support efficient querying for millions of students.
## User Roles & Permissions
The Users table stores each user’s tenant_id and role (e.g. “student” or “school_admin”). We could use a simple RBAC model: roles map to permissions, and each role is scoped to a tenant. For example, a SchoolAdmin role is valid only within one school. This follows industry advice that in multi-tenant SaaS, roles should be scoped to a particular tenant. Optionally, a linking table (user_roles) can allow multiple roles per user. Application logic (and RLS) then checks both the user’s role and their tenant: e.g. only an admin of School X can create or delete competitions for X. Higher-level “PlatformAdmin” roles (for site-wide operations) could be handled with a separate flag or a special global tenant.
## Authentication & Authorization
I recommend token-based auth (e.g. JWT) integrated with Supabase Auth or a similar identity provider. Upon login (via email/SAML/SSO), the Node.js backend issues a JWT containing user_id, tenant_id, and role. Node/Express middleware validates this token on each request and sets the database connection's user identity for RLS. Supabase's auth system naturally embeds the user's UID into auth.uid(), so RLS can use that to enforce the tenant_id = auth.uid() policy. For session-based flows, the Node.js API can verify the JWT on the server before sending data to the React frontend. All APIs check the JWT and user role (RBAC) before performing actions. We combine DB policies and application checks for defense-in-depth.
## Infrastructure & Scaling
We could containerize the Node/Express API and deploy on a managed cluster (AWS ECS/EKS or similar). AWS ECS is a strong choice because it efficiently optimizes resources and simplifies infrastructure for high availability. The Postgres database could be Amazon RDS (or a managed Postgres like Supabase) with read replicas for scale. Static assets (e.g. React build, images) and public competition pages can be served via CDN (AWS S3 + CloudFront) for global low-latency. We could use Infrastructure-as-Code (Terraform/CloudFormation) for automated provisioning, including autoscaling rules (e.g. AWS Auto Scaling).
For DNS and hosting, we could take advantage of wildcard domains: e.g. *.succeed.com points to our React frontend deployment (on AWS S3 + CloudFront, Netlify, or similar), which handles SSL and routing. For example, school1.succeed.com and school2.succeed.com would be served by the same static hosting infrastructure. We can issue SSL certificates and CDN distribution for each subdomain automatically. We also support custom domains (e.g. myschool.edu) by verifying DNS ownership and issuing certs programmatically. An API Gateway (or load balancer) fronts the Node API cluster, handling HTTPS termination, rate limiting, and routing. Overall this shared, stateless design scales to thousands of schools and millions of users.
## Frontend (React) and Backend (Node.js) Integration
The React frontend (built with Vite) consumes the Node.js backend via REST (or GraphQL) endpoints. Public competition pages can be optimized with client-side caching strategies (e.g., React Query, SWR) for performance. Authenticated pages use client-side data fetching with the school's JWT. The subdomain (or custom domain) determines the tenant context: React application code parses the hostname, sets the active tenant_id, and stores it in app state (e.g., using React Context or Redux). All API calls include the JWT (via Authorization header) so the backend knows the user's tenant. For example, when fetching competitions, the React client makes a request to the Node.js API with the JWT, the API then reads req.user and only returns that school's or public competitions per the RLS rules. This way the frontend only sees data it's authorized to see.
## AI (ChatGPT) Integration
We could integrate AI tools for content generation and moderation in a privacy-safe manner. For example, teachers might use ChatGPT to suggest competition questions or hints; students might receive automated feedback or hints from an AI coach. To protect privacy, we treat any student data carefully: we remove or anonymize PII before sending queries to the AI. We also train users not to paste personal info into prompts. On the backend, we call OpenAI’s API for suggestions. All requests can be filtered first through OpenAI’s Moderation endpoint, which flags disallowed content (hate, self-harm, etc.). According to OpenAI, this “GPT-based classifier” is free and can catch sexual, violent or harassing language. Any content failing moderation is blocked.
We could rely on OpenAI’s security model: for instance, ChatGPT’s Education offering is SOC2/GDPR-compliant and uses end-to-end encryption (TLS/AES). Notably, OpenAI does not train on our conversations or uploaded data, so student info isn’t leaked. We could store only aggregate or non-sensitive data about AI usage, and we could follow a zero-trust approach (only server-to-server AI calls, no direct student-ChatGPT link). Combined with strong access control, this ensures AI features “unlock benefits in education” safely.

By combining secure multi-tenant design (RLS, RBAC), modern cloud infrastructure, and careful AI integration, this architecture meets all requirements: it scales globally, isolates each school’s data, supports rich public/private sharing controls, and leverages GPT-powered features in a compliant, performant way.
